# 消息队列

## blog

[虽然看不懂](https://blog.csdn.net/lyhkmm/article/details/78775369)

[各种MQ比较(吹爆RabbitMQ)](http://www.imooc.com/article/79039)

## 为什么要使用MQ

* 解耦

  * Pub/Sub模型

* 异步

  传统模式的缺点：

  - 一些非必要的业务逻辑以同步的方式运行，太耗费时间。

  MQ模式：

  * 将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快相应速度

* 削峰

  传统模式的缺点：

  * 并发量大的时间，所有的请求直接怼到数据库，造成数据库连接异常

  MQ模式

  * 系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。
* 在调用高峰期，保证系统不会挂掉，请求都挤压在MQ中



### 缺点

* 系统可用性降低
  * 消息重复、丢失、顺序改变
  * 队列挂了 ，全部GG
  * 系统需要考虑的问题变多，导致系统复杂性变高
  * 一致性问题

1）数据驱动的任务依赖，多个任务需要轮流执行，轮流订阅上一个任务。 
2）上游不关心多下游执行结果，上游执行完发送到MQ，多下游订阅MQ。 
3）异步返回执行时间长 

## 队列模型

传递模型： 
1、点多点模型PTP 
每个消息只用一个消费者 
发送者和接收者没有时间依赖 
接受者确认消息接受和处理成功 
2、发布-订阅模型Pub/Sub 
一对多关系，通过订阅主题，发布者建立一个订阅，订阅者保持持续的活动状态以接收消息。 
每个消息可以有多个订阅者 
客户端只有订阅后才能接收到消息，有时间依赖。 
持久订阅 订阅关系建立后，消息不会消失，不管订阅者是否都在线 
非持久订阅 订阅者为了接受消息，必须一直在线



## 各种队列的区别

* ActiveMQ
  * 万级承受量
  * 大家都在用
  * 偶尔会丢消息
  * 社区维护少
* RabbitMq
  * 万级承受量
  * 基于erlang语言，但是如果想扩展就不容易
  * 提供管理界面
* RocketMQ
  * 阿里开发，10万级吞吐
  * 消息可靠性
  * java源码
* Kafka
  * 10万级吞吐
  * 功能简单
  * 易拓展
  * 适合大数据
  * 日志采集

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                 | kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| 开发语言   | java                                                         | erlang                                                       | java                     | scala                                                        |
| 单机吞吐量 | 万级                                                         | 万级                                                         | 10万级                   | 10万级                                                       |
| 时效性     | ms级                                                         | us级                                                         | ms级                     | ms级以内                                                     |
| 可用性     | 高(主从架构)                                                 | 高(主从架构)                                                 | 非常高(分布式架构)       | 非常高(分布式架构)                                           |
| 功能特性   | 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 | 基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富 | MQ功能比较完备，扩展性佳 | 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。 |

## 问题

[blog](https://www.cnblogs.com/angle6-liu/p/10792400.html)

### 如何保证高可用

搭集群

不同MQ的集群搭建方法不同



### 如何保证消息不被重复消费（幂等性）

#### 为何产生重复消费

其实无论是哪种消息队列，造成重复消费原因其实都是类似的。正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。只是不同的消息队列发出的确认消息形式不同，例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offet的概念，简单说一下，就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。

**那造成重复消费的原因？** 

就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。

#### 何如解决

（1）比如，你拿到这个消息做数据库的insert操作，那就容易了，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。

（2）再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。

（3）如果上面两种情况还不行，上大招。准备一个第三方介质，来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将<id,message>以K-V形式写入redis.那消费者开始消费前，先去redis中查询有没有消费记录即可。

### 如何保证消费的可靠性传输

其实这个可靠性传输，每种MQ都要从三个角度来分析：

- 生产者弄丢数据

从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。transaction机制就是说，发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降。

- 消息队列弄丢数据

处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步

1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列
2. 发送消息的时候将deliveryMode=2

这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据

- 消费者弄丢数据

消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rabbitMQ会立即将消息删除，这种情况下，如果消费者出现异常而未能处理消息，就会丢失该消息。

至于解决方案，采用手动确认消息即可。

### 如何保证消息的顺序性





### 消息怎么路由？

从概念上来说，消息路由必须有三部分：**交换器、路由、绑定**。生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。

1. 消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。
2. 通过队列路由键，可以把队列绑定到交换器上。
3. 消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。

常用的交换器主要分为一下三种：

- direct：如果路由键完全匹配，消息就被投递到相应的队列
- fanout：如果交换器收到消息，将会广播到所有绑定的队列上
- topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符，比如：“*” 匹配特定位置的任意文本， “.” 把路由键分为了几部分，“#” 匹配所有规则等。特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由"."隔开的一系列的标识符组成。

###  如何确保消息接收方消费了消息？

接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。

这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。

 

下面罗列几种特殊情况：

- 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）
- 如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。