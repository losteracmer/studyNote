# 电子提案系统

## 分析阶段

### 功能设计

**公共部分：**

登录登出

修改密码

公告展示



**管理：**

提案视图

届次设置

对提案的操作 CRUD



**代表：**

查看提案

提出提案

修改未进行到下一步的提案

对提案处理结果进行评价



**委员会主任：**

提案查看 （ 刚刚提出的提案，往届的提案？）

分类提案



**党政办：**

查看 已经建议/立案的 提案

对提案指派部门



**校党委：**

查看已经指派的提案

确认批复提案



**部门代表：**

查看指派给自己的提案

回复提案





### 各种进度的提案UI处理

对于每种进度 （撰写提案，分类提案，签发提案，处理提案，评价提案）

分别做一个div的窗口，各自编辑，然后同步到主窗体 （提案显示窗体，到底是窗体还是一个页面还没想好 。。最大窗口显示？）

其中比较难处理的权限划分不同操作问题

登录后在本地缓存登录者的权限(这里要不做成  数组？),然后根据权限判断是否显示

话说在提案视图这一页，是不是也要根据用户权限进行分类进行显示？



> 时间不多了，抓紧把这个项目完成

## JPA 相关

### 级联

级联对象的外键 Pid  在外部对象中，如果级联了 proposal ，就不能包含pid这个字段  

/TODO

* CascadeType.PERSIST 级联新增（又称级联保存）： 
   获取A对象里也同时也重新获取最新的B时的对象。即会重新查询数据库里的最新数据，并且，只有A类新增时，会级联B对象新增。若B对象在数据库存（跟新）在则抛异常（让B变为持久  态），对应EntityManager的presist方法,调用JPA规范中的persist()，不适用于Hibernate的save()方法
* CascadeType.REMOVE
   Cascade remove operation，级联删除操作。
   删除当前实体时，与它有映射关系的实体也会跟着被删除。
* CascadeType.MERGE
   Cascade merge operation，级联更新（合并）操作。
   当Student中的数据改变，会相应地更新Course中的数据。
* CascadeType.DETACH
   Cascade detach operation，级联脱管/游离操作。
   如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。
* CascadeType.REFRESH
   Cascade refresh operation，级联刷新操作。
   假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,再将订单及商品保存。
* CascadeType.ALL
   Cascade all operations，清晰明确，拥有以上所有级联操作权限。

### many to one

> 为何 @ManyToOne 加在属性上，和加在get方法上，效果还不一样呢

多对一 没有必要在 多的一方 （有set，或者list 属性的那一方） 配置注解

只要在一 的一方配置 @ManyToOne ，设置JoinColume(name = "IDKey")  也能达到效果

这里的外键不能喝外键对应的实体类同时存在，而在多的一方 ，外键和实体set可以同时存在

### 日志级别配置

```yml
logging:
  level:
    root: info
    cn.edu.henu.controller: debug
    cn.edu.henu.service: debug
```





## Ngnix

> 前后端分离，是时候配置一波反向代理了

在哪之前，熟悉几条Windows的命令

```shell
 tasklist | findstr nginx
 taskkill /pid XXX /F  # 强行终止某个进程
```

### ngnix 命令

```shell
nginx.exe #启动
nginx.exe -s stop
nginx.exe -s quit  # stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。
nginx.exe -s reload  #当配置信息修改，需要重新载入这些配置时使用此命令。
nginx.exe -t # 检查配置文件是否出错
```

## 参数验证

### @valid 注解

```java
public class ProposalListForm {
    @NotNull(message = "pageSize不能为空！")
    private Integer pageSize;

    @NotNull(message = "pageNum不能为空！")
    private Integer pageNum;
}
```

**form 类：**

```java
if (bindingResult.hasErrors()) {
            FieldError error = (FieldError) bindingResult.getAllErrors().get(0);
            String defaultMessage = error.getDefaultMessage();
            return ResultVOUtil.error(403, defaultMessage);
        }
```

这样就能在参数没有传入的时候返回定义的信息啦！还是很好用的

## 坑

### idea 的坑

> 刚开始就spring init 加载不出来，总是到某些jar包就停那了，难受...

```sh
mvn -U idea:idea
```

谁知道这是什么神仙命令，运行后，跑个半个小时，一切问题都没了

### MySQL链接

> 有个什么时区问题，需要在链接的url上加点东西

```mysql
serverTimezone=GMT
```

### 又是maven

> 不知道是不是网络问题，一直卡在 resolving maven dependencies

网上找的解决方法，在setting  build  build_tools  maven importing 更改参数

```mvn
修改maven Importing的jvm参数, 默认为700多, 直接修改成 -Xms1024m -Xmx2048m
```

### jpa 驼峰命名

> 驼峰命名会被自动转成数据库下划线命名，指定@Column的name也不起作用

配置文件添加

```java
spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
```

yml:

```yml
  jpa:
    show-sql: true
    hibernate:
      naming:
        implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

```

### Mysql 时区问题

> 遇到前端刚刚插入内容少了8个小时，原因可能有两个：
>
> 是不是mysql的时区问题 
>
> 也可能是JackSon 的解析问题





## 项目日志

### 坑爹的数据表结构

针对 proposal 的 提案人，现在已经无法解决，，故不得不增加数据库字段proId

```sql
ALTER TABLE `dztaxt`.`approval_table` 
ADD COLUMN `ProId` int(11) AFTER `ProNum`;
```



```sql
UPDATE proposal_table l 
SET ProId = (
SELECT
	ProId 
FROM
	proposer_table r 
WHERE
	r.PeriodId = l.PeriodId 
	AND r.OrderId = l.OrderId 
	AND r.ProNum = l.ProNum 
	LIMIT 0,1
	);
```

执行上面的操作，初始化proId，剩下的冗余字段先不管了吧

> 竟然发现了一些bug数据？当初始怎么做的？

对于其他的表，签发表，审核表，都在Pronum的基础上增加ProId 字段 ，冗余字段暂时保留

```sql
-- ausstellung_table
-- ausstellung_table
-- approval_table
-- excuteproposal_table
UPDATE disposeproposal_table ll 
SET ProId = (
SELECT
	r.ProId
FROM
	proposer_table r,
	proposal_table l 
WHERE
	r.PeriodId = l.PeriodId 
	AND r.OrderId = l.OrderId 
	AND r.ProNum = ll.ProNum 
	AND ll.PId = l.PId
	order by r.UserType 
 LIMIT 0,1
	);
```

但是还是因为数据库历史原因，某些提案步骤的处理人的id就是找不到，可能是把原来的数据删了吧，为了能让程序正常跑起来，不出现太多的null数据，暂时死马当活马医吧

```sql
-- 将空数据按照pronum 找到最近的那个提案处理人填充上(管它是什么职位)
UPDATE ausstellung_table ll
SET ProId = (
SELECT ProId
FROM proposer_table r 
WHERE r.ProNum = ll.ProNum 
ORDER BY UserType
LIMIT 0,1)
WHERE ProId IS null;
```



! 疯了，数据库到底是怎么回事，怎么那么多冗余数据

```sql
	SELECT * FROM proposer_table r WHERE (SELECT count(*) FROM proposer_table r2 WHERE  r2.OrderId = r.OrderId and r2.ProNum = r.ProNum)>1 order by ProNum
```

突然明白，原来数据库中的那些冗余数据，并不是不小心添加多了，而是根本就是为了多个权限而添加的同一个届次，不同的权限，但是，为什么还有那种连权限都相同的呢？？？